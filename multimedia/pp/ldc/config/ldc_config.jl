#
# Copyright: Copyright 2018 Broadcom Limited.
# This program is the proprietary software of Broadcom Limited
# and/or its licensors, and may only be used, duplicated, modified
# or distributed pursuant to the terms and conditions of a separate,
# written license agreement executed between you and Broadcom
# (an "Authorized License").  Except as set forth in an Authorized
# License, Broadcom grants no license (express or implied), right
# to use, or waiver of any kind with respect to the Software, and
# Broadcom expressly reserves all rights in and to the Software
# and all intellectual property rights therein.  IF YOU HAVE
# NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
# IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
# ALL USE OF THE SOFTWARE.
#
# Except as expressly set forth in the Authorized License,
#
# 1.     This program, including its structure, sequence and organization,
# constitutes the valuable trade secrets of Broadcom, and you shall use
# all reasonable efforts to protect the confidentiality thereof,
# and to use this information only in connection with your use of
# Broadcom integrated circuit products.
#
# 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
# PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
# REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
# OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
# DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
# NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
# ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
# CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
# OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
#
# 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
# BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
# INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
# ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
# TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
# THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
# WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
# ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
#

using EzXML
using Images
using Polynomials

import EzXML.Document

include("bcm_fixed_point_numbers.jl")

################################################################################
# Registery of the LDC configurations
################################################################################
struct LdcConfiguration
    #
    # Width and height of the images used to model the lens
    # distortion. This should match the maximum resolution that
    # the image sensor in the camera module supports.
    #
    model_width::Int64
    model_height::Int64

    #
    # Width and height of the input image to the lens distortion
    # function on the target.
    #
    input_width::Int64
    input_height::Int64

    #
    # Width and height of the output image computed by the lens
    # distortion function on the target.
    #
    output_width::Int64
    output_height::Int64

    #
    # We expect that a crop followed by an aspect ratio preserving downscale
    # is applied to the image from the sensor to arrive at the image that is
    # being fed to the input of the distortion correction function.
    #
    # To recompute the appropriate distortion correction function for this
    # setup, we will need to know these parametres.
    #
    sensor_crop_x::Int64
    sensor_crop_y::Int64
    sensor_crop_w::Int64
    sensor_crop_h::Int64

    #
    # Distortion correction function generated by the modeler.
    #
    # (xc, yc) is the distortion center.
    #
    # (c0, c1, c2, c3, c4) are the coefficients of the distortion
    # correction polynomial.
    #
    xc::Float64
    yc::Float64

    c0::Float64
    c1::Float64
    c2::Float64
    c3::Float64
    c4::Float64

    #
    # Number of MP cores that will be running the LDC firmware,
    # and the tile size it will be operating with.
    #
    num_cores::Int64

    tile_size::Int64

    num_tiles_output_x::Int64
    num_tiles_output_y::Int64

    #
    # The maximum span of the MBRows in the input image that the
    # LDC implementation can handle while correcting one MBROW in the
    # output image
    #
    max_mbrow_span::Int64

    #
    # File names
    #
    ldc_cfg_xml_file_name::String
    ldc_cfg_bin_file_name::String

    min_mbrow_dump_file_name::String
    max_mbrow_dump_file_name::String
    mesh_coeff_dump_file_name::String
    correction_func_visual_file_name::String

    #
    # Constructor
    #
    LdcConfiguration(
        cfg_name,
        mw, mh,
        iw, ih,
        ow, oh,
        crop_x, crop_y, crop_w, crop_h,
        xc, yc,
        c0, c1, c2, c3, c4,
        num_cores,
        max_mbrow_span) = begin

        MAX_DIM = 2048

        tile_size = 16
        @assert(ispow2(tile_size))

        #
        # Sanity checks
        #
        @assert((mw > 0) && (mw <= MAX_DIM), "LDC config with invalid model width $mw requested")
        @assert((mh > 0) && (mh <= MAX_DIM), "LDC config with invalid model height $mh requested")
        @assert((iw > 0) && (iw <= MAX_DIM), "LDC config with invalid input width $iw requested")
        @assert((ih > 0) && (ih <= MAX_DIM), "LDC config with invalid input height $ih requested")
        @assert((ow > 0) && (ow <= MAX_DIM), "LDC config with invalid output width $ow requested")
        @assert((oh > 0) && (oh <= MAX_DIM), "LDC config with invalid output height $oh requested")
        @assert((num_cores > 0) && (num_cores <=4), "LDC config with invalid num_cores $num_cores requested")
        @assert((xc > 1) && (xc < mw), "LDC config with invalid dist_center $xc, $yc requested")
        @assert((yc > 1) && (yc < mh), "LDC config with invalid dist_center $xc, $yc requested")
        @assert((crop_x >= 0) && (crop_x < mw) &&
                (crop_y >= 0) && (crop_y < mh) &&
                (crop_w > 0) && (crop_h > 0)  &&
                ((crop_x + crop_w) <= mw)     &&
                ((crop_y + crop_h) <= mh),
            "LDC config with invalid sensor crop $((crop_x, crop_y, crop_w, crop_h)) requested"
        )
        @assert((max_mbrow_span > 0) && (max_mbrow_span <= 16),
            "LDC config with invalid max mbrow span $max_mbrow_span requested")

        downscale_x = Float64(crop_w) / Float64(iw)
        downscale_y = Float64(crop_h) / Float64(ih)
        @assert(((downscale_x >= 1) && (downscale_y >= 1) && isapprox(downscale_x, downscale_y)),
            "LDC config with invalid image transformations requested."
        )

        #
        # We expect the input/output image dimensions to be rounded to the tile size.
        #
        @assert(rem(iw, tile_size) == 0)
        @assert(rem(ih, tile_size) == 0)
        @assert(rem(ow, tile_size) == 0)
        @assert(rem(oh, tile_size) == 0)

        ntx = Int(ow / tile_size)
        nty = Int(oh / tile_size)

        #
        # Generate the file names for the mesh dump and min_max_mbrow dump
        #
        ldc_cfg_xml_file_name = "ldc_config_" * cfg_name * ".xml"
        ldc_cfg_bin_file_name = "ldc_config_" * cfg_name * ".bin"
        min_mbrow_dump_file_name = "ldc_min_mbrow_" * cfg_name * ".bin"
        max_mbrow_dump_file_name = "ldc_max_mbrow_" * cfg_name * ".bin"
        mesh_coeff_dump_file_name = "ldc_mesh_" * cfg_name * ".bin"
        correction_func_visual_file_name = "ldc_mesh_vis_" * cfg_name * ".png"

        #
        # Create object
        #
        new(mw, mh, iw, ih, ow, oh,
            crop_x, crop_y, crop_w, crop_h,
            xc - 1, yc - 1,
            c0, c1, c2, c3, c4,
            num_cores,
            tile_size, ntx, nty,
            max_mbrow_span,
            ldc_cfg_xml_file_name, ldc_cfg_bin_file_name,
            min_mbrow_dump_file_name, max_mbrow_dump_file_name,
            mesh_coeff_dump_file_name,
            correction_func_visual_file_name
        )

    end
end

const LDC_CONFIG_REGISTERY = Dict(
    "ox3a_720p_1mp" => LdcConfiguration(
        "ox3a_720p_1mp",         # Config name
        1920, 1280,              # Model width and height
        1280, 720,               # Input image width and height
        1280, 720,               # Output image width and height
        328, 288, 1280, 720,     # Crop applied to the sensor image
        980.422586214244,        # Distortion center x
        646.274236988581,        # Distortion center y
        2.0766899886703314,      # c0
        -0.0023585641404572665,  # c1
        1.0664020906306502e-6,   # c2
        3.3896875245046666e-11,  # c3
        -1.0735303742199053e-13, # c4
        1,                       # num_cores
        8                        # max_mbrow_span
    ),
    "ox3a_720p_ds_1mp" => LdcConfiguration(
        "ox3a_720p_ds_1mp",      # Config name
        1920, 1280,              # Model width and height
        1280, 720,               # Input image width and height
        1280, 720,               # Output image width and height
        0, 100, 1920, 1080,      # Crop applied to the sensor image
        980.422586214244,        # Distortion center x
        646.274236988581,        # Distortion center y
        2.0766899886703314,      # c0
        -0.0023585641404572665,  # c1
        1.0664020906306502e-6,   # c2
        3.3896875245046666e-11,  # c3
        -1.0735303742199053e-13, # c4
        1,                       # num_cores
        8                        # max_mbrow_span
    ),
    "ox3a_720p_ds_2mp" => LdcConfiguration(
        "ox3a_720p_ds_2mp",      # Config name
        1920, 1280,              # Model width and height
        1280, 720,               # Input image width and height
        1280, 720,               # Output image width and height
        0, 100, 1920, 1080,      # Crop applied to the sensor image
        980.422586214244,        # Distortion center x
        646.274236988581,        # Distortion center y
        2.0766899886703314,      # c0
        -0.0023585641404572665,  # c1
        1.0664020906306502e-6,   # c2
        3.3896875245046666e-11,  # c3
        -1.0735303742199053e-13, # c4
        2,                       # num_cores
        8                        # max_mbrow_span
    ),
    "ox3a_1080p_2mp" => LdcConfiguration(
        "ox3a_1080p_2mp",        # Config name
        1920, 1280,              # Model width and height
        1920, 1088,              # Input image width and height
        1920, 1088,              # Output image width and height
        0, 100, 1920, 1088,      # Crop applied to the sensor image
        980.422586214244,        # Distortion center x
        646.274236988581,        # Distortion center y
        2.0766899886703314,      # c0
        -0.0023585641404572665,  # c1
        1.0664020906306502e-6,   # c2
        3.3896875245046666e-11,  # c3
        -1.0735303742199053e-13, # c4
        2,                       # num_cores
        16                       # max_mbrow_span
    ),
    "ov9716_720p_1mp" => LdcConfiguration(
        "ov9716_720p_1mp",       # Config name
        1392, 976,               # Model width and height
        1280, 720,               # Input image width and height
        1280, 720,               # Output image width and height
        58, 100, 1280, 720,      # Crop applied to the sensor image
        685.0423564814951,       # Distortion center x
        449.5307971256129,       # Distortion center y
        1.1807485744404318,      # c0
        -2.2982476026081046e-5,  # c1
        -1.3307283739298107e-6,  # c2
        1.2504433770985065e-9,   # c3
        -3.7246002080667405e-13, # c4
        1,                       # num_cores
        8                        # max_mbrow_span
    ),
    "ox3a_720p_1mp_lite" => LdcConfiguration(
        "ox3a_720p_1mp_lite",    # Config name
        1392, 976,               # Model width and height
        1280, 720,               # Input image width and height
        1280, 720,               # Output image width and height
        58, 100, 1280, 720,      # Crop applied to the sensor image
        685.0423564814951,       # Distortion center x
        449.5307971256129,       # Distortion center y
        1.1807485744404318,      # c0
        -2.2982476026081046e-5,  # c1
        -1.3307283739298107e-6,  # c2
        1.2504433770985065e-9,   # c3
        -3.7246002080667405e-13, # c4
        1,                       # num_cores
        8                        # max_mbrow_span
    ),
)

################################################################################
# Distortion correction function adjustment.
################################################################################
struct AdjustedLDCParams{T <: AbstractFloat}
    #
    # Distortion center
    #
    xc::T
    yc::T

    #
    # Radial distortion correction polynomial coefficients
    #
    c0::T
    c1::T
    c2::T
    c3::T
    c4::T
end

function distortion_correct(dist_correct_params::AdjustedLDCParams{T}, xu, yu) where T

    #
    # Distance of (xu, yu) from the distortion center and its powers
    #
    r_pow2 = (xu - dist_correct_params.xc)^2 + (yu - dist_correct_params.yc)^2
    r = sqrt(r_pow2)

    r_pow3 = r * r_pow2
    r_pow4 = r_pow2 * r_pow2

    #
    # (xd - xc) = (xu - xc) * (c0 + c1*r + c2*r_pow2 + c3*r_pow3...)
    # (yd - yc) = (yu - yc) * (c0 + c1*r + c2*r_pow2 + c3*r_pow3...)
    #
    common_factor = (dist_correct_params.c0) +
                    (dist_correct_params.c1 * r) +
                    (dist_correct_params.c2 * r_pow2) +
                    (dist_correct_params.c3 * r_pow3) +
                    (dist_correct_params.c4 * r_pow4)

    xd = dist_correct_params.xc + ((xu - dist_correct_params.xc) * common_factor)
    yd = dist_correct_params.yc + ((yu - dist_correct_params.yc) * common_factor)

    (xd, yd)
end

function adjust_distortion_correction_function(config::LdcConfiguration)
    #
    # Compute the distortion center in the input image given the
    # distortion center in the full resolution image.
    #
    # The image goes through a crop and a downscale.
    #
    xc_cropped_img = config.xc - config.sensor_crop_x
    yc_cropped_img = config.yc - config.sensor_crop_y

    @assert((xc_cropped_img > 0) && (xc_cropped_img < config.sensor_crop_w))
    @assert((yc_cropped_img > 0) && (yc_cropped_img < config.sensor_crop_h))

    # Aspect ratio during a downscale is preserved
    scale_factor = (config.input_width / config.sensor_crop_w)

    xc_adj = xc_cropped_img * scale_factor
    yc_adj = yc_cropped_img * scale_factor

    c0_adj = config.c0 * scale_factor
    c1_adj = config.c1 * scale_factor
    c2_adj = config.c2 * scale_factor
    c3_adj = config.c3 * scale_factor
    c4_adj = config.c4 * scale_factor

    #
    # Adjust the polynomial.
    #

    #
    # Start off by imposing the constraint that given
    #   ru = distance from the distortion center to the nearest side and
    #   rd = radial_dist_correct(ru)
    # We require that ru = rd
    #
    # TODO: Explain the computation below.
    #
    side_distances_from_dist_center = [
        (xc_adj, xc_adj),
        (yc_adj, yc_adj),
        (config.input_width - xc_adj, config.output_width - xc_adj),
        (config.input_height - yc_adj, config.output_height - yc_adj)
    ]

    input_nearest_side_dist, output_nearest_side_dist =
        reduce(side_distances_from_dist_center) do (input_side1, output_side1), (input_side2, output_side2)
            if input_side1 < input_side2
                (input_side1, output_side1)
            else
                (input_side2, output_side2)
            end
        end

    ru_farthest = maximum([
        sqrt((xc_adj^2) + (yc_adj^2)),
        sqrt((config.output_width - xc_adj)^2 + (yc_adj^2)),
        sqrt((xc_adj^2) + (config.output_height - yc_adj)^2),
        sqrt((config.output_width - xc_adj)^2 + (config.output_height - yc_adj)^2),
    ])

    ru_current = filter(roots(Poly([-input_nearest_side_dist, c0_adj, c1_adj, c2_adj, c3_adj, c4_adj]))) do root
        isreal(root) && (real(root) > 0) && (real(root) < ru_farthest)
    end[1] |> real

    scale = ru_current / output_nearest_side_dist

    c0_adj *= scale
    c1_adj *= scale^2
    c2_adj *= scale^3
    c3_adj *= scale^4
    c4_adj *= scale^5

    #
    # Now, check if this new model meets our max_mbrow_span constraint set
    # in the config.
    #
    # First, we tweak the distortion correction curve to pull in more content
    # from the corners of the image. This should also help reduce the mbrow span.
    #
    # If we do not still meet our max_mbrow_span constraint, we scale the model
    # by adjusting the zoom factor.
    #

    #
    # Helper to compute the mbrow span
    #
    compute_mbrow_span(ldc_params) = begin

        max_num_mbrows_needed = 0

        for j in 0:(config.num_tiles_output_y - 1)
            min_y = Inf
            max_y = 0

            y = j * config.tile_size

            for x in 0:(config.output_width - 1)
                (xdu, ydu) = distortion_correct(ldc_params, x, y)
                (xdl, ydl) = distortion_correct(ldc_params, x, y + config.tile_size - 1)

                @assert(ydl > ydu)

                min_y = min(min_y, ydu)
                max_y = max(max_y, ydl)
            end

            #
            # We addd 1 to max_y to take interpolation into account.
            # Another 1 is added to max_y to take the mesh + fixed point
            # conversion errors into account. For the same reason, we substact
            # 1 from min_y
            #

            min_y -= 1
            max_y += 2

            min_mbrow = div(min_y, config.tile_size)
            max_mbrow = div(max_y, config.tile_size)

            num_mbrows_needed = (max_mbrow - min_mbrow + 1)
            max_num_mbrows_needed = max(num_mbrows_needed, max_num_mbrows_needed)
        end

        max_num_mbrows_needed
    end


    #
    # Correction curve tweak
    #
    comp_factor = 0.0

    sampled_rus = collect(0:ru_farthest)
    sampled_corr_func = map(sampled_rus) do ru
        (c0_adj*ru) + (c1_adj*(ru^2)) + (c2_adj*(ru^3)) + (c3_adj*(ru^4)) + (c4_adj*(ru^5))
    end
    new_corr_func = similar(sampled_corr_func)
    num_samples = length(sampled_rus)

    nearest_side_idx = (floor(input_nearest_side_dist) + 1) |> Int
    sampled_corr_func_nearest = sampled_corr_func[nearest_side_idx]

    spline_mat = inv([
        sampled_corr_func_nearest^3 sampled_corr_func_nearest^2 sampled_corr_func_nearest 1;
        ru_farthest^3 ru_farthest^2 ru_farthest 1;
        3*sampled_corr_func_nearest^2 2*sampled_corr_func_nearest 1 0;
        3*ru_farthest^2 2*ru_farthest 1 0
    ])

    # Preallocate arrays that we will use for curve fitting
    POLY_DEGREE = 5
    A = Array{Float64, 2}(undef, num_samples, POLY_DEGREE)
    B = Array{Float64}(undef, num_samples)

    while comp_factor < 1.0

        max_num_mbrows_needed = compute_mbrow_span(
            AdjustedLDCParams{Float64}(xc_adj, yc_adj, c0_adj, c1_adj, c2_adj, c3_adj, c4_adj))

        if max_num_mbrows_needed <= config.max_mbrow_span
            break
        else
            comp_factor += 0.1
        end

        #
        # We use the spline below to pull the distortion correction curve
        # towards the line (ru - rd = 0). comp_factor decides the extent to which
        # we pull the curve.
        #
        spline = spline_mat * [0, comp_factor, 0, 0]
        a = spline[1]
        b = spline[2]
        c = spline[3]
        d = spline[4]

        for (idx, rd) in enumerate(sampled_corr_func)
            if idx < nearest_side_idx
                new_corr_func[idx] = sampled_corr_func[idx]
            else
                ru = idx - 1
                w = (a*(ru^3)) + (b*(ru^2)) + (c*ru) + d
                new_corr_func[idx] = (rd + (w * (ru - rd)))
            end
        end

        #
        # Fit a new curve through the data points in the new_corr_func.
        #
        for (idx, (x, y)) in enumerate(zip(sampled_rus, new_corr_func))
            for i in 1:POLY_DEGREE
                A[idx, i] = x^i
            end

            B[idx] = y
        end

        C = A \ B
        c0_adj = C[1]
        c1_adj = C[2]
        c2_adj = C[3]
        c3_adj = C[4]
        c4_adj = C[5]
    end

    #
    # Zoom factor tweak
    #
    zoom_factor = 1.0

    while true

        c0 = c0_adj * zoom_factor
        c1 = c1_adj * zoom_factor^2
        c2 = c2_adj * zoom_factor^3
        c3 = c3_adj * zoom_factor^4
        c4 = c4_adj * zoom_factor^5

        max_num_mbrows_needed = compute_mbrow_span(
            AdjustedLDCParams{Float64}(xc_adj, yc_adj, c0, c1, c2, c3, c4)
        )

        if max_num_mbrows_needed <= config.max_mbrow_span
            break
        else
            zoom_factor -= 0.02
        end
    end

    #
    # Adjust the zoom factor furthur so that our implementation
    # constraints are met.
    #
    while true
        c0 = c0_adj * zoom_factor
        c1 = c1_adj * zoom_factor^2
        c2 = c2_adj * zoom_factor^3
        c3 = c3_adj * zoom_factor^4
        c4 = c4_adj * zoom_factor^5

        ldc_params = AdjustedLDCParams{Float64}(xc_adj, yc_adj, c0, c1, c2, c3, c4)
        dist_correction_func(x, y) = distortion_correct(ldc_params, x, y)
        mesh = compute_mesh(config.tile_size, config.num_tiles_output_y, config.num_tiles_output_x,
            dist_correction_func)

        if check_impl_constraints(mesh)
            break
        else
            zoom_factor -= 0.02
        end
    end

    return AdjustedLDCParams{Float32}(
        Float32(xc_adj),
        Float32(yc_adj),
        Float32(c0_adj * zoom_factor),
        Float32(c1_adj * zoom_factor^2),
        Float32(c2_adj * zoom_factor^3),
        Float32(c3_adj * zoom_factor^4),
        Float32(c4_adj * zoom_factor^5)
    )
end

################################################################################
# Mesh computation
################################################################################

#
# Fixed point representations of the coefficients
#
const A0_Type = BcmN12f4
const B0_Type = BcmN12f4
const A1_Type = BcmN2f6
const A2_Type = BcmQ1f6
const B1_Type = BcmQ1f6
const B2_Type = BcmN2f6
const CommonFixedType = BcmQ25f6

#
# Validate the types set.
#
requested_fixedp_types = [A0_Type, B0_Type, A1_Type, A2_Type, B1_Type, B2_Type]
for T in requested_fixedp_types
    @assert(T <: BcmFixedPoint, "Type $T is not a valid fixed point type")
    @assert(sizeof(T) <= 2, "Type $T takes up more than 16 bits, and is unsupported")
end
@assert(CommonFixedType <: BcmFixedPoint, "Type $CommonFixedType is not a valid fixed point type")
@assert(sizeof(CommonFixedType) == 4, "Fixed point type with unexpected size $(sizeof(CommonFixedType)) encountered")

#
# Mesh element data structure
#
struct DistCorrectMeshElt

    #
    # Coefficients in floating point.
    #
    a0_float::Float32
    a1_float::Float32
    a2_float::Float32
    b0_float::Float32
    b1_float::Float32
    b2_float::Float32

    #
    # Fixed point representations of the coefficients as
    # stored in the table fed to the MP.
    #
    a0_fixed::A0_Type
    a1_fixed::A1_Type
    a2_fixed::A2_Type
    b0_fixed::B0_Type
    b1_fixed::B1_Type
    b2_fixed::B2_Type

    #
    # Fixed point type used for computations.
    #
    a0_fixed_com::CommonFixedType
    a1_fixed_com::CommonFixedType
    a2_fixed_com::CommonFixedType
    b0_fixed_com::CommonFixedType
    b1_fixed_com::CommonFixedType
    b2_fixed_com::CommonFixedType

    #
    # Error statistics
    #
    err_mesh_avg::Float32
    err_mesh_max::Float32
    err_fixedp_avg::Float32
    err_fixedp_max::Float32

end

#
# Mesh coefficient and per-tile error statistics computations.
#
function compute_mesh(tile_size, num_mbrows, num_mbcols, dist_correction_func)
    #
    # Helper function to compute the norm2 distance
    #
    norm2_dist(x1, y1, x2, y2) = ((x2 - x1)^2 + (y2 - y1)^2) |> sqrt

    #
    # The following matrix is used to compute the bilinear approximation
    # of the distortion correction function over a tile.
    #
    mat::Array{Float32,2} =
        inv([1                     0               0;
             1        (tile_size - 1)              0;
             1 Float32(tile_size / 2) (tile_size - 1)])

    #
    # The matrix above is hard-coded in the target software for
    # tile_size = 16. We check if the literals hard-coded there
    # are in agreement with the computation above.
    #
    @assert(tile_size == 16)
    @assert(isapprox(mat[1, 1],  1.0))
    @assert(isapprox(mat[2, 1], -0.0666667))
    @assert(isapprox(mat[2, 2],  0.0666667))
    @assert(isapprox(mat[3, 1], -0.0311111))
    @assert(isapprox(mat[3, 2], -0.0355556))
    @assert(isapprox(mat[3, 3],  0.0666667))

    #
    # Generate the mesh
    #
    mesh = Array{DistCorrectMeshElt, 2}(undef, num_mbcols, num_mbrows)

    for (tx, ty) in Iterators.product(0:num_mbcols-1, 0:num_mbrows-1)
        #
        # Evaluate the distortion correction function at the -
        # 1. Top left corner
        # 2. Top right corner
        # 3. Mid-point of the bottom edge
        #
        xu_left   = Float32(tile_size * tx)
        yu_left   = Float32(tile_size * ty)
        xu_right  = Float32(xu_left + (tile_size - 1))
        yu_right  = Float32(yu_left)
        xu_bottom = Float32(xu_left + (tile_size / 2))
        yu_bottom = Float32(yu_left + (tile_size - 1))

        xd_left, yd_left = dist_correction_func(xu_left, yu_left)
        xd_right, yd_right = dist_correction_func(xu_right, yu_right)
        xd_bottom, yd_bottom = dist_correction_func(xu_bottom, yu_bottom)

        #
        # Compute the coefficients by applying the matrix computed above.
        #
        a0_float = xd_left
        a1_float = -(0.0666667f0 * xd_left) + (0.0666667f0 * xd_right)
        a2_float = -(0.0311111f0 * xd_left) - (0.0355556f0 * xd_right) + (0.0666667f0 * xd_bottom)

        b0_float = yd_left
        b1_float = -(0.0666667f0 * yd_left) + (0.0666667f0 * yd_right)
        b2_float = -(0.0311111f0 * yd_left) - (0.0355556f0 * yd_right) + (0.0666667f0 * yd_bottom)

        #
        # Compute the corresponding fixed point representations
        #
        a0_fixed = convert(A0_Type, a0_float)
        a1_fixed = convert(A1_Type, a1_float)
        a2_fixed = convert(A2_Type, a2_float)

        b0_fixed = convert(B0_Type, b0_float)
        b1_fixed = convert(B1_Type, b1_float)
        b2_fixed = convert(B2_Type, b2_float)

        a0_fixed_com = convert(CommonFixedType, a0_fixed)
        a1_fixed_com = convert(CommonFixedType, a1_fixed)
        a2_fixed_com = convert(CommonFixedType, a2_fixed)

        b0_fixed_com = convert(CommonFixedType, b0_fixed)
        b1_fixed_com = convert(CommonFixedType, b1_fixed)
        b2_fixed_com = convert(CommonFixedType, b2_fixed)

        #
        # Compute the error statistics
        #
        err_mesh_accum = 0f0
        err_mesh_max = 0f0
        err_fixedp_accum = 0f0
        err_fixedp_max = 0f0

        for (dx, dy) in Iterators.product(0:tile_size-1, 0:tile_size-1)
            #
            # Evaluate the distortion correction function at every pixel
            # in the tile. Compare it to the mesh approximation, and mesh
            # approximation after fixed point conversion.
            #
            xd, yd = dist_correction_func((xu_left + dx), (yu_left + dy))

            xdm = a0_float + (dx * a1_float) + (dy * a2_float)
            ydm = b0_float + (dx * b1_float) + (dy * b2_float)

            xdm_fp = convert(Float32, a0_fixed_com + (dx * a1_fixed_com) + (dy * a2_fixed_com))
            ydm_fp = convert(Float32, b0_fixed_com + (dx * b1_fixed_com) + (dy * b2_fixed_com))

            err_mesh = norm2_dist(xd, yd, xdm, ydm)
            err_fixedp = norm2_dist(xd, yd, xdm_fp, ydm_fp)

            # Update variables
            err_mesh_max = (err_mesh > err_mesh_max) ? err_mesh : err_mesh_max
            err_fixedp_max = (err_fixedp > err_fixedp_max) ? err_fixedp : err_fixedp_max

            err_mesh_accum += err_mesh
            err_fixedp_accum += err_fixedp
        end

        #
        # Compute error averages, insert the mesh element.
        #
        err_mesh_avg = err_mesh_accum / (tile_size)^2
        err_fixedp_avg = err_fixedp_accum / (tile_size)^2

        mesh[tx + 1, ty + 1] = DistCorrectMeshElt(
            a0_float, a1_float, a2_float,
            b0_float, b1_float, b2_float,
            a0_fixed, a1_fixed, a2_fixed,
            b0_fixed, b1_fixed, b2_fixed,
            a0_fixed_com, a1_fixed_com, a2_fixed_com,
            b0_fixed_com, b1_fixed_com, b2_fixed_com,
            err_mesh_avg, err_mesh_max,
            err_fixedp_avg, err_fixedp_max)
    end

    mesh
end

#
# Check if all the constraints imposed on the coefficients by the LDC routine
# on the vMP are met.
#
function check_impl_constraints(mesh)

    # Helper function to check the span constraints
    check_span_constraints(mesh_elt, out_span_x, out_span_y, in_span_x, in_span_y) = begin
        #
        # Reduce the inSpan by 1 to accomodate the translation term
        # arising from the fractional parts.
        # TODO: Explain better?
        #
        in_span_x = Float32(in_span_x - 1)
        in_span_y = Float32(in_span_y - 1)
        in_span_x_fixedp = convert(CommonFixedType, in_span_x)
        in_span_y_fixedp = convert(CommonFixedType, in_span_y)

        #
        # Helper to compute the distortion correction function
        # using the mesh approximation.
        #
        transform(x, y) = begin
            x̂ = mesh_elt.a0_fixed_com + (x * mesh_elt.a1_fixed_com) + (y * mesh_elt.a2_fixed_com)
            ŷ = mesh_elt.b0_fixed_com + (x * mesh_elt.b1_fixed_com) + (y * mesh_elt.b2_fixed_com)
            (x̂, ŷ)
        end

        p0 = transform(0, 0)
        p1 = transform(out_span_x - 1, 0)
        p2 = transform(0, out_span_y - 1)
        p3 = transform(out_span_x - 1, out_span_y - 1)

        in_span_computer(idx) = begin
            coords = [p0[idx], p1[idx], p2[idx], p3[idx]]
            min = minimum(coords)
            max = maximum(coords)
            (max - min)
        end

        spanx = in_span_computer(1)
        spany = in_span_computer(2)

        (spanx < in_span_x_fixedp) && (spany < in_span_y_fixedp)
    end

    #
    # Loop over each mesh element and check if the constraints are
    # met
    #
    num_mbcols, num_mbrows = size(mesh)
    for (tx, ty) in Iterators.product(1:num_mbcols, 1:num_mbrows)

        mesh_elt = mesh[tx, ty]
        #
        # The implementation assumes that all the pixels it needs to
        # correct a 4x4 block of pixels are contained in an 8x8 block
        # in the input image.
        #
        # Since the implementation also performs bilinear interpolation,
        # we require that the transformed polygon can be contained inside
        # a 7x7 block in the input image space.
        #
        if !check_span_constraints(mesh_elt, 4, 4, 7, 7)
            return false
        end

        #
        # Furthurmore, the core loop of the implementation assumes that
        # to correct a 4x1 block, all we need is an 8x3 block from the
        # input (well, 7x2 and one pixel in each direction for interpolation).
        #
        if !check_span_constraints(mesh_elt, 4, 1, 7, 2)
            return false
        end

        #
        # Finally, we assume that a 16x16 block is contained in a 32x28
        # block from the input, and a 8x8 block is contained in a 16x14
        #
        # Again, take interpolation into account.
        #
        if (!check_span_constraints(mesh_elt, 16, 16, 31, 27)) || (!check_span_constraints(mesh_elt, 8, 8, 15, 13))
            return false
        end

        # We also require that the sign of a2 and b1 be the same.
        @assert((raw(mesh_elt.a2_fixed_com) * raw(mesh_elt.b1_fixed_com)) >= 0)

        # Also, we expect a1 and b2 to always be positive.
        @assert(raw(mesh_elt.a1_fixed) >= 0)
        @assert(raw(mesh_elt.b2_fixed) >= 0)
    end

    return true
end

#
# Dump the mesh coefficients in their fixed point representations.
# The dump is meant to be hex-diffable with a memory dump pulled off from
# the target platform for debugging. Also meant to be an input to the MP
# simulator.
#
function mesh_dump(mesh, file_name)

    open(file_name, "w") do fhdl
        # Helper function
        # hton - Host to Network byte order (big-endian).
        write_to_file(x::BcmFixedPoint{T,f}) where {T, f} = write(fhdl, hton(raw(x)))

        w, h = size(mesh)
        for (i, j) in Iterators.product(1:w, 1:h)
            mesh[i, j].b2_fixed |> write_to_file
            mesh[i, j].b1_fixed |> write_to_file
            mesh[i, j].a2_fixed |> write_to_file
            mesh[i, j].a1_fixed |> write_to_file
            mesh[i, j].b0_fixed |> write_to_file
            mesh[i, j].a0_fixed |> write_to_file
        end
    end

end

#
# Dump the min and max mbrow values.
# The dump is meant to be hex-diffable with a memory dump pulled off from
# the target platform for debugging.
#
function min_max_mbrow_dump(tile_size, mesh, min_mbrow_dump_file_name, max_mbrow_dump_file_name)

    # The min-max mbrow info is not computed during the mesh
    # generation. Do it now.
    num_mbcols, num_mbrows = size(mesh)

    # Get the number of fraction bits used for the common fixedp
    # type in the mesh
    nfracbits = nbitsfrac(CommonFixedType)

    # Indicates the maximum number of mbrows needed to be
    # buffered inside the LDC's implementation.
    max_num_mbrows_needed = 0

    open(min_mbrow_dump_file_name, "w") do min_mbrow_fhdl
    open(max_mbrow_dump_file_name, "w") do max_mbrow_fhdl

    for j in 0:num_mbrows-1

        # Initialize these guys to extremes
        min_y = num_mbrows * tile_size
        max_y = 0

        for i in 0:num_mbcols-1
            elt = mesh[i + 1, j + 1]

            mb_min_y_fixed = 0
            mb_max_y_fixed = 0

            if elt.a2_float >= 0
                # In this case, (0, 0)'s transformation
                # will have the minimum y over the tile, and
                # (tile_size - 1, tile_size - 1)'s transformation
                # will have the max y
                mb_min_y_fixed = raw((elt.b0_fixed_com))
                mb_max_y_fixed = raw((elt.b0_fixed_com) +
                              ((tile_size - 1) * elt.b1_fixed_com) +
                              ((tile_size - 1) * elt.b2_fixed_com))
            else
                # Here, (tile_size - 1, 0)'s transformation will
                # have the minimum y over the tile, and
                # (0, tile_size - 1)'s transformation will have the
                # max y
                mb_min_y_fixed = raw((elt.b0_fixed_com) + ((tile_size - 1) * elt.b1_fixed_com))
                mb_max_y_fixed = raw((elt.b0_fixed_com) + ((tile_size - 1) * elt.b2_fixed_com))
            end

            # Floor mb_min_y. Floor mb_max_y, and add 1 to take
            # interpolation into account.
            mb_min_y = (mb_min_y_fixed >> nfracbits)
            mb_max_y = (mb_max_y_fixed >> nfracbits) + 1

            # Update min_y and max_y
            if mb_min_y < min_y
                min_y = mb_min_y
            end

            if mb_max_y > max_y
                max_y = mb_max_y
            end
        end

        # Compute min and max mbrows, and update the variables.
        min_mbrow = div(min_y, tile_size)
        max_mbrow = div(max_y, tile_size)

        num_mbrows_needed = (max_mbrow - min_mbrow + 1)

        if num_mbrows_needed > max_num_mbrows_needed
            max_num_mbrows_needed = num_mbrows_needed
        end

        # File ops
        write(min_mbrow_fhdl, UInt8(min_mbrow))
        write(max_mbrow_fhdl, UInt8(max_mbrow))
    end
    end
    end

    println("Num mbrows needed in the circ buffer: $max_num_mbrows_needed")
end

#
# Print Error statistics
#
function print_global_error_statistics(mesh)
    #
    # compute_mesh function computed the error statistics at a tile
    # granularity. Compute the global statistics, print them.
    #
    global_err_mesh_max = 0
    global_err_mesh_accum = 0
    global_err_fixedp_max = 0
    global_err_fixedp_accum = 0

    count = 0

    for elt in mesh
        global_err_mesh_accum += elt.err_mesh_avg
        global_err_fixedp_accum += elt.err_fixedp_avg

        global_err_mesh_max =
            if elt.err_mesh_max > global_err_mesh_max
                elt.err_mesh_max
            else
                global_err_mesh_max
            end

        global_err_fixedp_max =
            if elt.err_fixedp_max > global_err_fixedp_max
                elt.err_fixedp_max
            else
                global_err_fixedp_max
            end

        count += 1
    end

    # Compute global averages
    global_err_mesh_avg = global_err_mesh_accum / count
    global_err_fixedp_avg = global_err_fixedp_accum / count

    println("Error introduced due to mesh approximation (in pix dist) : $(global_err_mesh_avg) avg, $(global_err_mesh_max) max")
    println("Error after the fixed point conversion of the mesh coefficients (in pix dist) : $(global_err_fixedp_avg) avg, $(global_err_fixedp_max) max")
end

################################################################################
# Dump configuration file
################################################################################
license_text = """
 Copyright 2018 Broadcom Limited.  All rights reserved.

 This program is the proprietary software of Broadcom Limited and/or its
 licensors, and may only be used, duplicated, modified or distributed pursuant
 to the terms and conditions of a separate, written license agreement executed
 between you and Broadcom (an "Authorized License").

 Except as set forth in an Authorized License, Broadcom grants no license
 (express or implied), right to use, or waiver of any kind with respect to the
 Software, and Broadcom expressly reserves all rights in and to the Software
 and all intellectual property rights therein.  IF YOU HAVE NO AUTHORIZED
 LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD
 IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.

  Except as expressly set forth in the Authorized License,
 1. This program, including its structure, sequence and organization,
    constitutes the valuable trade secrets of Broadcom, and you shall use all
    reasonable efforts to protect the confidentiality thereof, and to use this
    information only in connection with your use of Broadcom integrated
    circuit products.

 2. TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
    AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR
    WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT
    TO THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED
    WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A
    PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS,
    QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION.
    YOU ASSUME THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE
    SOFTWARE.

 3. TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS
    LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT,
    OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
    YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN
    ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS
    OF THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. \$1, WHICHEVER
    IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
    ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
"""

const LDC_CFG_MAGIC   = UInt32(0x44575250)
const LDC_CFG_VERSION = UInt32(0x64)

function write_config_file(ldc_config, adjusted_ldc_params)

    # Helper
    hex(a::Float32) = "0x" * string(reinterpret(UInt32, a), base = 16, pad = 8)

    #
    # We use the EzXML package to generate the xml file for us.
    #
    doc_node = XMLDocumentNode("1.0")

    # Write the license header.
    licence_header = CommentNode(license_text)
    link!(doc_node, licence_header)

    #
    # Root node
    #
    root_node = ElementNode("ldc_config")
    link!(doc_node, root_node)

    #
    # Width and height
    #
    input_width_node = ElementNode("input_width")
    setnodecontent!(input_width_node, "$(ldc_config.input_width)")
    link!(root_node, input_width_node)

    input_height_node = ElementNode("input_height")
    setnodecontent!(input_height_node, "$(ldc_config.input_height)")
    link!(root_node, input_height_node)

    output_width_node = ElementNode("output_width")
    setnodecontent!(output_width_node, "$(ldc_config.output_width)")
    link!(root_node, output_width_node)

    output_height_node = ElementNode("output_height")
    setnodecontent!(output_height_node, "$(ldc_config.output_height)")
    link!(root_node, output_height_node)

    #
    # number of MP cores
    #
    num_mpcores_node = ElementNode("num_mp_cores")
    setnodecontent!(num_mpcores_node, "$(ldc_config.num_cores)")
    link!(root_node, num_mpcores_node)


    #
    # Distortion center
    #
    dist_center_x_comment = CommentNode("dist center x = $(adjusted_ldc_params.xc)")
    link!(root_node, dist_center_x_comment)

    dist_center_node_x = ElementNode("dist_center_x")
    setnodecontent!(dist_center_node_x, hex(adjusted_ldc_params.xc))
    link!(root_node, dist_center_node_x)

    dist_center_y_comment = CommentNode("dist center y = $(adjusted_ldc_params.yc)")
    link!(root_node, dist_center_y_comment)

    dist_center_node_y = ElementNode("dist_center_y")
    setnodecontent!(dist_center_node_y, hex(adjusted_ldc_params.yc))
    link!(root_node, dist_center_node_y)

    #
    # Distortion correction polynomial coefficients
    #
    dist_correct_coeff_0_comment = CommentNode("coeff 0 = $(adjusted_ldc_params.c0)")
    link!(root_node, dist_correct_coeff_0_comment)

    dist_correct_coeff_0 = ElementNode("dist_correct_poly_coeff0")
    setnodecontent!(dist_correct_coeff_0, hex(adjusted_ldc_params.c0))
    link!(root_node, dist_correct_coeff_0)

    dist_correct_coeff_1_comment = CommentNode("coeff 1 = $(adjusted_ldc_params.c1)")
    link!(root_node, dist_correct_coeff_1_comment)

    dist_correct_coeff_1 = ElementNode("dist_correct_poly_coeff1")
    setnodecontent!(dist_correct_coeff_1, hex(adjusted_ldc_params.c1))
    link!(root_node, dist_correct_coeff_1)

    dist_correct_coeff_2_comment = CommentNode("coeff 2 = $(adjusted_ldc_params.c2)")
    link!(root_node, dist_correct_coeff_2_comment)

    dist_correct_coeff_2 = ElementNode("dist_correct_poly_coeff2")
    setnodecontent!(dist_correct_coeff_2, hex(adjusted_ldc_params.c2))
    link!(root_node, dist_correct_coeff_2)

    dist_correct_coeff_3_comment = CommentNode("coeff 3 = $(adjusted_ldc_params.c3)")
    link!(root_node, dist_correct_coeff_3_comment)

    dist_correct_coeff_3 = ElementNode("dist_correct_poly_coeff3")
    setnodecontent!(dist_correct_coeff_3, hex(adjusted_ldc_params.c3))
    link!(root_node, dist_correct_coeff_3)

    dist_correct_coeff_4_comment = CommentNode("coeff 4 = $(adjusted_ldc_params.c4)")
    link!(root_node, dist_correct_coeff_4_comment)

    dist_correct_coeff_4 = ElementNode("dist_correct_poly_coeff4")
    setnodecontent!(dist_correct_coeff_4, hex(adjusted_ldc_params.c4))
    link!(root_node, dist_correct_coeff_4)

    #
    # Write to the file
    #
    io = IOBuffer()
    prettyprint(io, doc_node)
    write(ldc_config.ldc_cfg_xml_file_name, take!(io))

    #
    # TEMP - Write the bin file as well
    #
    open(ldc_config.ldc_cfg_bin_file_name, "w") do hdl
        # Header
        write(hdl, LDC_CFG_MAGIC)
        write(hdl, LDC_CFG_VERSION)

        # Input width and height
        write(hdl, UInt32(ldc_config.input_width))
        write(hdl, UInt32(ldc_config.input_height))

        # Output width and height
        write(hdl, UInt32(ldc_config.output_width))
        write(hdl, UInt32(ldc_config.output_height))

        # Num cores
        write(hdl, UInt32(ldc_config.num_cores))

        # Distortion center
        write(hdl, reinterpret(UInt32, adjusted_ldc_params.xc))
        write(hdl, reinterpret(UInt32, adjusted_ldc_params.yc))

        # Distortion coefficients
        write(hdl, reinterpret(UInt32, adjusted_ldc_params.c0))
        write(hdl, reinterpret(UInt32, adjusted_ldc_params.c1))
        write(hdl, reinterpret(UInt32, adjusted_ldc_params.c2))
        write(hdl, reinterpret(UInt32, adjusted_ldc_params.c3))
        write(hdl, reinterpret(UInt32, adjusted_ldc_params.c4))
    end
end

################################################################################
# Correction function visualization and dewarp
################################################################################
function visualize_distortion_correction_func(
    input_width, input_height, output_width, output_height, file_name, correct_func)

    JMP = 40

    #
    # Allocate and fill the image buffer
    #
    img = Array{Gray{N0f8}, 2}(undef, input_height, input_width)
    fill!(img, Gray{N0f8}(0.4))

    #
    # Helper to color one point on the image
    #
     mark(xu, yu) = begin

        xdf, ydf = correct_func(xu, yu)

        yd = ydf |> round |> Int
        xd = xdf |> round |> Int

        for i in -1:1
            for j in -1:1

                if ((yd + j) >= 1 && (yd + j) <= input_height && (xd + i) >= 1 && (xd + i) <= input_width)
                    img[yd + j, xd + i] = Gray{N0f8}(1.0)
                end

            end
        end

    end

    #
    # Draw horizontal lines
    #
    for y in 0:JMP:(output_height-1)
        for x in 0:(output_width-1)
            mark(x, y)
        end
    end

    for x in 0:(output_width-1)
        mark(x, output_height-1)
    end


    #
    # Draw vertical lines
    #
    for x in 0:JMP:(output_width-1)
        for y in 0:(output_height-1)
            mark(x, y)
        end
    end

    for y in 0:(output_height-1)
        mark(output_width-1, y)
    end


    #
    # Save to disk
    #
    save(file_name, img)
end

function dewarp_image(
    dewarp_input_file_name, dewarp_output_file_name,
    cfg_name, input_width, input_height,
    output_width, output_height, dist_correction_func)

    #
    # Load, verify dimensions
    #
    img = load(dewarp_input_file_name)
    h, w = size(img)
    @assert((w == input_width) && (h == input_height),
        """
        Input image for dewarping does not have the right dimensions to
        apply the correction function defined by the $cfg_name config.
        """
    )

    #
    # Allocate output image and dewarp
    #
    img2 = similar(img, output_height, output_width)

    for j in 0:(output_height - 1)
        for i in 0:(output_width-1)

        xdf, ydf = dist_correction_func(i, j)

            yd0 = ydf |> floor |> Int
            yd1 = yd0 + 1
            xd0 = xdf |> floor |> Int
            xd1 = xd0 + 1

            yf = ydf - yd0
            xf = xdf - xd0

            if yd0 < 0 || yd0 >= (h-1) || xd0 < 0 || xd0 >= (w-1)
                img2[j + 1, i + 1] = RGB{N0f8}(0.0, 0.0, 0.0)
            else
                p00 = img[yd0 + 1, xd0 + 1]
                p01 = img[yd0 + 1, xd1 + 1]
                p10 = img[yd1 + 1, xd0 + 1]
                p11 = img[yd1 + 1, xd1 + 1]

                pix = (1-yf)*(1-xf)*p00 + (1-yf)*(xf)*p01 + (yf)*(1-xf)*p10 + (yf)*(xf)*p11

                img2[j + 1, i + 1] = convert(RGB{N0f8}, pix)
            end
        end
    end

    save(dewarp_output_file_name, img2)
end

################################################################################
# User Interface and main
################################################################################
function print_help()
    println("Usage : $PROGRAM_FILE [-c --config-name] config_name [--dump-mesh] [--dump-min-max-mbrow] [--visualize] [--dewarp] input_file_name output_file_name")
    println()

    println("Required arguments:")
    println("[-c, --config-name]        Valid config name")
    println()

    println("Optional arguments:")
    println("[--dump-mesh]              Dump the computed mesh. For debugging and simulator input. Dump filename predermined.")
    println("[--dump-min-max-mbrow]     Dump the computed min and max mbrow info. Dump filename predermined.")
    println("[--visualize]              Dump the image to visualize the adjusted distortion correction function. Dump filename predermined.")
    println("[--dewarp]                 Dewarp the image with the correction function computed from the config specified.")
    println()

    println("Valid config names are: ")

    for (i, key) in enumerate(keys(LDC_CONFIG_REGISTERY))
        println("$i : $key")
    end
    println()

    println("To view/add/edit/remove configurations, edit the LDC_CONFIG_REGISTERY variable inside the script.")
end

function parse_command_line_args()

    config_name = ""
    dump_mesh = false
    dump_min_max_mbrow_info = false
    visualize_correct_func = false
    dewarp_input_file_name = ""
    dewarp_output_file_name = ""

    if length(ARGS) > 0

    skip_args_count = 0

    for i in 1:length(ARGS)

        if skip_args_count > 0
            skip_args_count -= 1
            continue
        end

        if (ARGS[i] == "-h") || (ARGS[i] == "--help")

            print_help()
            exit(0)

        elseif (ARGS[i] == "-c" || ARGS[i] == "--config-name")

            if config_name != "" || i == length(ARGS) || !haskey(LDC_CONFIG_REGISTERY, ARGS[i + 1])
                println("Invalid config name on the command line")
                print_help()
                exit(-1)
            end

            config_name = ARGS[i + 1]
            skip_args_count = 1

        elseif (ARGS[i] == "--dump-mesh")

            dump_mesh = true

        elseif (ARGS[i] == "--dump-min-max-mbrow")

            dump_min_max_mbrow_info = true

        elseif (ARGS[i] == "--visualize")

            visualize_correct_func = true

        elseif (ARGS[i] == "--dewarp")

            if (i == length(ARGS)) || ((i + 1) == length(ARGS))
                println("Input and output Image files to dewarp not set on the command line")
                print_help()
                exit(-1)
            end

            dewarp_input_file_name = ARGS[i + 1]
            dewarp_output_file_name = ARGS[i + 2]
            skip_args_count = 2

        else

            println("Unknown command line arg $(ARGS[i])")
            print_help()
            exit(-1)

        end

    end
    end

    if config_name == ""
        println("Config name not specified on the command line")
        print_help()
        exit(-1)
    end

    (config_name, dump_mesh, dump_min_max_mbrow_info, visualize_correct_func,
        dewarp_input_file_name, dewarp_output_file_name)
end

function main()

    #
    # Parse command line, read off the config from the registery
    #
    (cfg_name, dump_mesh, dump_min_max_mbrow_info, visualize_correct_func,
    dewarp_input_file_name, dewarp_output_file_name) = parse_command_line_args()

    ldc_config = LDC_CONFIG_REGISTERY[cfg_name]

    #
    # Compute the adjusted distortion function.
    #
    adjusted_ldc_params = adjust_distortion_correction_function(ldc_config)
    dist_correction_func(xu, yu) = distortion_correct(adjusted_ldc_params, xu, yu)

    #
    # Compute mesh, check impl constraints.
    #
    mesh = compute_mesh(ldc_config.tile_size, ldc_config.num_tiles_output_y, ldc_config.num_tiles_output_x,
        dist_correction_func)
    @assert(check_impl_constraints(mesh))

    print_global_error_statistics(mesh)

    #
    # Dump the config xml and  bin files.
    #
    write_config_file(ldc_config, adjusted_ldc_params)

    #
    # Optional dumps
    #
    if dump_mesh
        mesh_dump(mesh, ldc_config.mesh_coeff_dump_file_name)
    end

    if dump_min_max_mbrow_info
        min_max_mbrow_dump(ldc_config.tile_size, mesh,
            ldc_config.min_mbrow_dump_file_name,
            ldc_config.max_mbrow_dump_file_name)
    end

    #
    # Mesh visualization if requested
    #
    if visualize_correct_func
        visualize_distortion_correction_func(
            ldc_config.input_width,
            ldc_config.input_height,
            ldc_config.output_width,
            ldc_config.output_height,
            ldc_config.correction_func_visual_file_name,
            dist_correction_func)
    end

    #
    # Dewarp if requested
    #
    if dewarp_input_file_name != ""
        dewarp_image(
            dewarp_input_file_name,
            dewarp_output_file_name,
            cfg_name,
            ldc_config.input_width,
            ldc_config.input_height,
            ldc_config.output_width,
            ldc_config.output_height,
            dist_correction_func)
    end

end

main()
